"use strict";

document.addEventListener('DOMContentLoaded', function () { // Обработчик события, который запускает функцию только когда структура страницы загружена

    function getTimeRemaining(endtime) { // Создаем функцию, возвращающую разницу между текущим временем и окончанием акции (с датой окончания акции в аргументах)
        const now = new Date(), // Присваиваем переменной текущую дату и время
              t = Date.parse(endtime) - Date.parse(now), // Присваиваем переменной разницу между окончанием и текущим временем в милисекундах (потому что .parse)
              days = Math.floor((t / (1000 * 60 * 60 * 24))), // Конвертируем милисекунды в дни (делим разницу в милисикундах на 1000 милисек, на 60 сек, на 60 мин и на 24 часа)
              hours = Math.floor((t / (1000 * 60 * 60) % 24)), // Конвертируем милисекунды в часы (делим разницу в милисикундах на 1000 милисек, 60 сек и 60 мин. Берем остаток от деления на 24 часа)
              minutes = Math.floor((t / 1000 / 60) % 60), // Конвертируем милисекунды в минуты (делим разницу в милисикундах на 1000 милисек и на 60 сек. Берем остаток от деления на 60 минут)
              seconds = Math.floor((t / 1000) % 60); // Конвертируем милисекунды в секунды (просто делим разницу в милисекундах на 1000 милисек и берем остаток от деления на 60 секунд)

        return { // Возвращаем полученные выше данные в виде переменных
            'total': t, // Разница между текущим временем и окончанием акции в милисекундах
            'days': days, // Разница между текущим временем и окончанием акции в днях
            'hours': hours, // Разница между текущим временем и окончанием акции в часах
            'minutes': minutes, // Разница между текущим временем и окончанием акции в минутах
            'seconds': seconds // Разница между текущим временем и окончанием акции в секундах
        };

    }

    function getZero(num) { // Создаем функцию, в которой добавляем 0 к числу, если в нем менее двух цифр
        if (num >= 0 && num < 10) { // Если число более или равно 0 и менее 10
            return '0' + num; // Добавляем перед числом 0
        } else { // Иначе
            return num; // Возвращаем число как есть
        }
    }

    function setClock(selector, endtime) { // Создаем основную функцию, которая запускает обновление таймера

        const timer = document.querySelector(selector), // Определяем элемент в верстке, который является таймером
              days = timer.querySelector("#days"), // Какой элемент в верстке показывает дни?
              hours = timer.querySelector('#hours'), // Какой элемент в верстке показывает часы?
              minutes = timer.querySelector('#minutes'), // Какой элемент в верстке показывает минуты?
              seconds = timer.querySelector('#seconds'), // Какой элемент в верстке показывает секунды?
              timeInterval = setInterval(updateClock, 1000); // Таймер запускается/обновляется каждую секунду, чтобы показать ход оставшегося времени

        updateClock(); // Запускаем сейчас позже объявленную функцию, чтобы сразу показать оставшееся время, а не ждать целую секунду из-за setInterval

        function updateClock() { // Создаем функцию обновления таймера
            const t = getTimeRemaining(endtime); // Присваиваем константе разницу между текущим временем и окончанием акции в милисекундах

            days.innerHTML = getZero(t.days); // Вставляем актуальную цифру в верстку с остатком дней и добавляем в начало 0, если нужно
            hours.innerHTML = getZero(t.hours); // Вставляем актуальную цифру в верстку с остатком часов и добавляем в начало 0, если нужно
            minutes.innerHTML = getZero(t.minutes); // Вставляем актуальную цифру в верстку с остатком минут и добавляем в начало 0, если нужно
            seconds.innerHTML = getZero(t.seconds); // Вставляем актуальную цифру в верстку с остатком секунд и добавляем в начало 0, если нужно

            if (t.total <= 0) { // Если разница между текущим временем и окончанием акции меньше или равна нулю (в милисекундах),
                clearInterval(timeInterval); // то отменяем многократные повторения действий (обновление таймера), установленные вызовом функции setInterval()
            }
        }
    }

    const deadline = '2021-04-29'; // Указываем дату окончания акции

    // const day = new Date(); // Если нужно, создаем период, равный суткам
    // day.setDate(day.getDate() + 1); // Для этого прибавляем к текущей дате сутки, можно использовать переменную day

    setClock('.timer', deadline); // Запускаем функцию, обновляющую таймер (в аргументах - селектор из верстки и дата окончания акции)

});